#ifndef DUNGEONCPP_H
#define DUNGEONCPP_H

#include <stdint.h>
#include <iostream>
#include <vector>
#include "../headers/mon_file_parser"
#include "../headers/item_file_parser"
#include "constants.h"
#include "map.h"
#include "path_finder.h"
#include "character"
#include "item"
#include "heap.h"
#include "gameio.h"



class Dungeon{
private:
  character_creator mc;
  item_creator ic;

  Dungeon(int nummon){
    curlev = top = new level(nummon, 0);
  }

  static Dungeon *d_instance;
  Dungeon &operator=(Dungeon const&);
  Dungeon(Dungeon const&);

  class level{
  public:
    level(int nummon, int up_stairs);
    ~level();
    uint8_t x;
    uint8_t y;
    uint8_t look;
    uint8_t hardness[mapHeight][mapWidth];
    uint8_t visited[mapHeight][mapWidth];
    char chars[mapHeight][mapWidth];
    uint16_t distances[mapHeight][mapWidth];
    uint16_t distances_notun[mapHeight][mapWidth];
    uint16_t distances_intel[mapHeight][mapWidth];
    character *characters[mapHeight][mapWidth];
    item *items[mapHeight][mapWidth];
    pc *player;
    room_t *rooms;
    uint8_t numRooms;
    uint32_t num_characters;
    level *upstairs;
    level *downstairs;
    heap *turn_order;
    std::string message;
  };

  level *curlev;
  level *top;

public:

  ~Dungeon();

  static Dungeon *get_instance(int nummon);

  static Dungeon *get_instance();

  inline void center_map(){
    curlev->x = curlev->player->x;
    curlev->y = curlev->player->y;
  }

  inline char &get_environment(int x, int y){
    return curlev->chars[y][x];
  }

  inline std::string &get_message(){
      return curlev->message;
  }

  inline heap_t *get_turns(){
    return curlev->turn_order;
  }

  inline uint8_t &get_x(){
    return curlev->x;
  }

  inline uint8_t &get_y(){
    return curlev->y;
  }

  inline uint8_t &get_look(){
    return curlev->look;
  }

  inline uint8_t &get_hardness(int x, int y){
    return curlev->hardness[y][x];
  }

  inline uint8_t &visited(int x, int y){
    return curlev->visited[y][x];
  }

  uint16_t *get_distance_array(const unsigned int attrib){
    if(attrib & intelligent){
      if(attrib & tunneler)
        return *curlev->distances_intel;
      else
        return *curlev->distances_notun;
    }
    else{
      return *curlev->distances;
    }
  }

  int can_see_player(int x, int y){
    return can_see(curlev->hardness, curlev->player->x, curlev->player->y, x, y);
  }

  inline uint32_t get_num_characters(){
    return curlev->num_characters;
  }

  room_t *get_room(int i){
    if(i < curlev->numRooms && i <= 0){
      return curlev->rooms + i;
    }
    return NULL;
  }

  inline uint8_t &get_num_rooms(){
    return curlev->numRooms;
  }

  int save(){
    if(saveMap(curlev->numRooms, curlev->rooms, curlev->hardness)){
      printf("failed to save map\n");
      return -1;
    }
    std::cout << "map saved" << std::endl;
    return 0;
  }

  int load(){
    if(loadMap(&curlev->rooms, &curlev->numRooms,  curlev->hardness)){
      return -1;
    }

    init_map_char(curlev->chars);
    drawMap(curlev->hardness, curlev->chars, curlev->rooms, curlev->numRooms);
    return 0;
  }

  char for_print(int x, int y);

  character *get_character(int x, int y);

  character *get_player(){
    return curlev->player;
  }

  item *get_item(int x, int y){
    return curlev->items[y][x];
  }

  void remove_item(int x, int y){
    if(curlev->items[y][x])
      delete curlev->items[y][x];
    curlev->items[y][x] = NULL;
  }

  void set_message(std::string a);

  int get_life(){
    return curlev->player->hp;
  }

  void set_character(int x, int y, character *c);

  int go_upstairs();

  int visible(int x, int y);

  int go_downstairs();

  void calculate_distances();

  void fill_level();

};




#endif
